
# A452 Practical Investigation Coursework

## Research

### Android
**What is Android?**

> Android is a mobile operating system (OS) currently developed by Google, based on the Linux kernel and designed primarily for touchscreen mobile devices such as smartphones and tablets. Android's user interface is mainly based on direct manipulation, using touch gestures that loosely correspond to real-world actions, such as swiping, tapping and pinching, to manipulate on-screen objects, along with a virtual keyboard for text input. In addition to touchscreen devices, Google has further developed Android TV for televisions, Android Auto for cars, and Android Wear for wrist watches, each with a specialized user interface. Variants of Android are also used on notebooks, game consoles, digital cameras, and other electronics.

> **Source(s):** https://en.wikipedia.org/wiki/Android_(operating_system)

**What Android systems will be used?**

Since a system running Android will be required, App Inventor's default emulator has been chosed as it's easy to use and set up.

### App Inventor
**What is App Inventor?**

> App Inventor for Android is an open-source web application originally provided by Google, and now maintained by the Massachusetts Institute of Technology (MIT).

> It allows newcomers to computer programming to create software applications for the Android operating system (OS). It uses a graphical interface, very similar to Scratch and the StarLogo TNG user interface, which allows users to drag-and-drop visual objects to create an application that can run on Android devices. In creating App Inventor, Google drew upon significant prior research in educational computing, as well as work done within Google on online development environments.

> **Source(s):** https://en.wikipedia.org/wiki/App_Inventor_for_Android

**Is App Inventor suitable for the task(s)?**

When researching about App Inventor, it seems to be capable of many functions but has a few limitations:

> **Capabilities**

> App Inventor's capabilities include:

> - Access to most of the phone's functionality: phone calls, SMS texting, sensors for location, orientation, and acceleration, > > text-to-speech and speech recognition, sound, video.
> - The ability to invoke other apps, with the ActivityStarter component
> - Programming control just as with a textual language. There are blocks for conditionals (if, ifelse), foreach, and while, and a fairly comprehensive list of math and logic blocks.
> - Database access, both on the device and on the web. So you can save data persistently, and with a web database share data amongst phones.
> - Access to web information sources (APIs)-- you can bring in data from Facebook, Amazon, etc. See limitations below.

> For a full listing of the components and blocks, see the component and block overview (https://sites.google.com/site/appinventor/component-ove).

> **Limitations**

> App Inventor has the following limitations in terms of the apps you can build:

> - **Limited UIs.** The user interface builder has improved but is still a bit buggy and limited, so you can't build any user interface. For instance, you can't create apps with multiple screens and handling orientation changes has some glitches. These problems are not fundamental to the design of App Inventor and will soon be fixed.
> - **Limited Access to the device.** There are not yet components for all the data and functionality of the phone. For instance, you can't save and retrieve files from the file system and you have only limited access to the contact list (e.g., you cannot create groups).
> - **Limited Access to Web.** You can only access APIs that follow a particular prototocol (App-Inventor-compatible APIs). So if you want to get data from the web, you'll need to program or have a programmer create an App-Inventor-Compliant API that wraps an existing API. 
> - **No polymorphic components.** Function blocks are tied to specific components, so there is no way to call functions on a generic component. For instance, if you create a procedure MoveXY, it has to be tied to a specific image sprite, not a general image sprite.
> - **Limited access to the Android Market.** The apps (.apk files) generated by App Inventor lack the required configuration for direct inclusion in the market. However, there is now a workaround for market publication. See instructions at http://www.androidworld.it/forum/app-inventor-91/%5Bhow-%5D-publish-app-created-app-inventor-android-market-4597/.

> **Source(s):** https://sites.google.com/site/appinventor/capabilities-limitations

To come to a conclusion, it seems that App Inventor is fully capable to achieving the set tasks; it features the core basic functions required for the task as it features:
- images
- sprites
- buttons
- text

In terms of its block programming, it seems that it too is also fully capable to achieving the set tasks; it features the core basic functions required for the task as it features:
- basic variable types (booleans, strings, numbers and lists)
- procedures
- events

**Source(s):** http://appinventor.mit.edu/explore/library.html

Further research of these features can be found in the ```Planning``` stage of each task.

As an experienced programmer who has experience in may other languages (including MSI's own Scratch), App Inventor lessons wont be required. Instead, my past experience, logic and App Inventor documentation (http://appinventor.mit.edu/explore/library.html) will be used.

In terms of time, no more than an hour (of the 20 hours given) should be spent on each stage, and the remaining time is to be used for perfecting.

## Task 1

### Planning
The task required me to obtain and display a map of a university campus, after looking through the App Inventor documentation, it seemed clear that the canvas component was perfect for the job; it's very flexible allowing me to place buttons in it which is required for future tasks.

![](http://i.imgur.com/wsuLGK2.png)

The "BackgroundImage" property can be used to hold the image, and for the future tasks, sprites can be placed in it as buttons.

![](http://code2flow.com/6y2pJv.png)

**Source(s)**: http://ai2.appinventor.mit.edu/reference/components/animation.html#Canvas

### Development
To obtain the campus image, I used the search engine "Google" and chose this one:

![](http://i.imgur.com/GHGvwoF.png)

A canvas was then added to the screen (which was renamed to "campus" for readability purposes) and the image was uploaded and set as the background image (through the use of the the "BackgroundImage" property:

![](http://i.imgur.com/XQSE7K6.png)
![](http://i.imgur.com/aH1dly2.png)

## Task 2

### Planning
This task required that each building was touchable and upon being touched the amount of computers available in that building is to be displayed. I thought of many ways to achieve this, but the most reasonable and logic method was to use ImageSprites as buttons.

The reasons for this is because the other option was to use balls, however, when making them invisible they're no longer touchable which was a large disappointment. However, I was able to achieve this by using ImageSrpties and making their image transparent.

I decided to place these buttons in the canvas that was created in the previous task. A label was then placed (outside of the canvas, in screen1) on top of the canvas which is to display the amount of buildings available.

![](http://i.imgur.com/pyJEN28.png)

**Source(s)**: http://appinventor.mit.edu/explore/content/animation.html

Labels have been chosen as they allow text to be displayed and edited through the use of the ```Text``` property.

![](http://i.imgur.com/phCcXH1.png)

**Source(s)**: http://ai2.appinventor.mit.edu/reference/components/userinterface.html#Label

![](http://code2flow.com/UA9BIn.png)

### Development
To start the development of this task, I placed an ```ImageSprite``` on each building and renamed them "b" + the number of the building they have been applied to. A transparent image, made using photoshop, was uploaded and set as their image. The image was then resized to fit the size of the building it's applied to (to allow the user to easily touch the building itself, rather than struggle to touch a small button).

A label called "bpc_text" (which stands for, building pc text - the text which will display the amount computers in the building) was then placed at the top, above the canvas. I allowed the size of it to be filled by the parent both length and height wise as that way the text can automatically fit on the screen.

![](http://i.imgur.com/xpn2JHh.png)

The next step required me to get into the techical programming side of things. Starting off, two global list were created, one called ```bpc_avaliable``` and the other called ```bpc_reserved```. ```bpc_avaliable```contained 14 items (the same amount of buildings on the campus image, each index will be the buildings number e.g. ```bpc_avaliable[1]``` would store the amount of buildings avaliable in the first building. Each building had a number of computers assigned to it (I decieded to make it go in chronological order starting from 0 to 13 for debugging purposes).

![](http://i.imgur.com/gxH17Vb.png)

Like previously, ```bpc_reserved``` is a global list which contains 14 items, however, instead of containing the number of comptuers avaliable in each building. It contains a ```Boolean``` (a value which can either store ```True```, or ```False```) used to check if the building already has a computer reserved or not (to prevent users from reserving more than one computer). These are all set to ```False``` as since the program has just started they obviously haven't reserved any yet.

![](http://i.imgur.com/DXRYyZ3.png)
