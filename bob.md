# A452 Practical Investigation Coursework

## Research

### Android
**What is Android?**

> Android is a mobile operating system (OS) currently developed by Google, based on the Linux kernel and designed primarily for touchscreen mobile devices such as smartphones and tablets. Android's user interface is mainly based on direct manipulation, using touch gestures that loosely correspond to real-world actions, such as swiping, tapping and pinching, to manipulate on-screen objects, along with a virtual keyboard for text input. In addition to touchscreen devices, Google has further developed Android TV for televisions, Android Auto for cars, and Android Wear for wrist watches, each with a specialized user interface. Variants of Android are also used on notebooks, game consoles, digital cameras, and other electronics.

> **Source(s):** https://en.wikipedia.org/wiki/Android_(operating_system)

**What Android systems will be used?**

Since a system running Android will be required, App Inventor's default emulator has been chosed as it's easy to use and set up.

### App Inventor
**What is App Inventor?**

> App Inventor for Android is an open-source web application originally provided by Google, and now maintained by the Massachusetts Institute of Technology (MIT).

> It allows newcomers to computer programming to create software applications for the Android operating system (OS). It uses a graphical interface, very similar to Scratch and the StarLogo TNG user interface, which allows users to drag-and-drop visual objects to create an application that can run on Android devices. In creating App Inventor, Google drew upon significant prior research in educational computing, as well as work done within Google on online development environments.

> **Source(s):** https://en.wikipedia.org/wiki/App_Inventor_for_Android

**Is App Inventor suitable for the task(s)?**

When researching about App Inventor, it seems to be capable of many functions but has a few limitations:

> **Capabilities**

> App Inventor's capabilities include:

> - Access to most of the phone's functionality: phone calls, SMS texting, sensors for location, orientation, and acceleration, > > text-to-speech and speech recognition, sound, video.
> - The ability to invoke other apps, with the ActivityStarter component
> - Programming control just as with a textual language. There are blocks for conditionals (if, ifelse), foreach, and while, and a fairly comprehensive list of math and logic blocks.
> - Database access, both on the device and on the web. So you can save data persistently, and with a web database share data amongst phones.
> - Access to web information sources (APIs)-- you can bring in data from Facebook, Amazon, etc. See limitations below.

> For a full listing of the components and blocks, see the component and block overview (https://sites.google.com/site/appinventor/component-ove).

> **Limitations**

> App Inventor has the following limitations in terms of the apps you can build:

> - **Limited UIs.** The user interface builder has improved but is still a bit buggy and limited, so you can't build any user interface. For instance, you can't create apps with multiple screens and handling orientation changes has some glitches. These problems are not fundamental to the design of App Inventor and will soon be fixed.
> - **Limited Access to the device.** There are not yet components for all the data and functionality of the phone. For instance, you can't save and retrieve files from the file system and you have only limited access to the contact list (e.g., you cannot create groups).
> - **Limited Access to Web.** You can only access APIs that follow a particular prototocol (App-Inventor-compatible APIs). So if you want to get data from the web, you'll need to program or have a programmer create an App-Inventor-Compliant API that wraps an existing API. 
> - **No polymorphic components.** Function blocks are tied to specific components, so there is no way to call functions on a generic component. For instance, if you create a procedure MoveXY, it has to be tied to a specific image sprite, not a general image sprite.
> - **Limited access to the Android Market.** The apps (.apk files) generated by App Inventor lack the required configuration for direct inclusion in the market. However, there is now a workaround for market publication. See instructions at http://www.androidworld.it/forum/app-inventor-91/%5Bhow-%5D-publish-app-created-app-inventor-android-market-4597/.

> **Source(s):** https://sites.google.com/site/appinventor/capabilities-limitations

To come to a conclusion, it seems that App Inventor is fully capable to achieving the set tasks; it features the core basic functions required for the task as it features:
- images
- sprites
- buttons
- text

In terms of its block programming, it seems that it too is also fully capable to achieving the set tasks; it features the core basic functions required for the task as it features:
- basic variable types (booleans, strings, numbers and lists)
- procedures
- events

**Source(s):** http://appinventor.mit.edu/explore/library.html

Further research of these features can be found in the ```Planning``` stage of each task.

As an experienced programmer who has experience in may other languages (including MSI's own Scratch), App Inventor lessons wont be required. Instead, my past experience, logic and App Inventor documentation (http://appinventor.mit.edu/explore/library.html) will be used.

In terms of time, no more than an hour (of the 20 hours given) should be spent on each stage, and the remaining time is to be used for perfecting.

## Task 1

### Planning
The task required me to obtain and display a map of a university campus, after looking through the App Inventor documentation, it seemed clear that the canvas component was perfect for the job; it's very flexible allowing me to place buttons in it which is required for future tasks.

![](http://i.imgur.com/wsuLGK2.png)

The "BackgroundImage" property can be used to hold the image, and for the future tasks, sprites can be placed in it as buttons.

![](http://code2flow.com/6y2pJv.code.png)

**Source(s)**: http://ai2.appinventor.mit.edu/reference/components/animation.html#Canvas

### Development
To obtain the campus image, I used the search engine "Google" and chose this one:

![](http://i.imgur.com/GHGvwoF.png)

A canvas was then added to the screen (which was renamed to "campus" for readability purposes) and the image was uploaded and set as the background image (through the use of the the "BackgroundImage" property:

![](http://i.imgur.com/XQSE7K6.png)
![](http://i.imgur.com/aH1dly2.png)

### Testing
To test and ensure the application worked as planned, the emulator was launched and connected to test:

![](http://i.imgur.com/l0sAyd4.png)

The outcome procued the result as planned so no further testing is required here. 

## Task 2

### Planning
This task required that each building was touchable and upon being touched the amount of computers available in that building is to be displayed. I thought of many ways to achieve this, but the most reasonable and logic method was to use ImageSprites as buttons.

The reasons for this is because the other option was to use balls, however, when making them invisible they're no longer touchable which was a large disappointment. However, I was able to achieve this by using ImageSrpties and making their image transparent.

I decided to place these buttons in the canvas that was created in the previous task. A label was then placed (outside of the canvas, in screen1) on top of the canvas which is to display the amount of buildings available.

![](http://i.imgur.com/pyJEN28.png)

**Source(s)**: http://appinventor.mit.edu/explore/content/animation.html

Labels have been chosen as they allow text to be displayed and edited through the use of the ```Text``` property.

![](http://i.imgur.com/phCcXH1.png)

**Source(s)**: http://ai2.appinventor.mit.edu/reference/components/userinterface.html#Label

![](http://code2flow.com/IL9xNN.code.png)

### Development
To start the development of this task, I placed an ```ImageSprite``` on each building and renamed them "b" + the number of the building they have been applied to. A transparent image, made using photoshop, was uploaded and set as their image. The image was then resized to fit the size of the building it's applied to (to allow the user to easily touch the building itself, rather than struggle to touch a small button).

A label called "bpc_text" (which stands for, building pc text - the text which will display the amount computers in the building) was then placed at the top, above the canvas. I allowed the size of it to be filled by the parent both length and height wise as that way the text can automatically fit on the screen.

![](http://i.imgur.com/xpn2JHh.png)

The next step required me to get into the techical programming side of things. Starting off, two global list were created, one called ```bpc_avaliable``` and the other called ```bpc_reserved```. ```bpc_avaliable```contained 14 items (the same amount of buildings on the campus image, each index will be the buildings number e.g. ```bpc_avaliable[1]``` would store the amount of buildings avaliable in the first building. Each building had a number of computers assigned to it (I decieded to make it go in chronological order starting from 0 to 13 for debugging purposes).

![](http://i.imgur.com/gxH17Vb.png)

Like previously, ```bpc_reserved``` is a global list which contains 14 items, however, instead of containing the number of comptuers avaliable in each building. It contains a ```Boolean``` (a value which can either store ```True```, or ```False```) used to check if the building already has a computer reserved or not (to prevent users from reserving more than one computer). These are all set to ```False``` as since the program has just started they obviously haven't reserved any yet.

![](http://i.imgur.com/DXRYyZ3.png)

The next step was to create the main backbone of the program: ```bpc_run```. This procedure is to be called when each button is pressed.

![](http://i.imgur.com/nNhSkfh.png)

The procedure takes the argument "n" (the number of the current building being pressed) and then procedes to call various other functions and blocks. A procudure has been used to prevent the use of code duplication (http://appinventor.mit.edu/explore/ai2/support/concepts/procedures.html).

The next step was to create another procedure which is designed to display the amount of computers avaliable for the selected building. 

![](http://i.imgur.com/fC19LV8.png)

Like before, the procedure takes the argument "n" for the exact same reason. Using the ```text``` property of the label created earlier, the text was then changed. The "join" function was used to concatenate "There are " with the current amount of computers avaliable (through the use of "select list item list" which allows me to lookup the amount avaliable using "n" which is the current building) and finally added to " computers available in this building." which creates a nice outcome e.g. "There are 10  computers available in this building".

And finally, an event was checked for each button to see if they had been touched. If they were touched, the procedure "run" was called with the building number being passed:

![](http://i.imgur.com/zfvWzzh.png)

Final result:

![](http://i.imgur.com/pW2Pk5P.png)

### Testing
To test if the program is working correctly, a test table has been corrected to test the outcome of each button.

|Button |Expected outcome                    |Actual outcome                       |✔/✘|
|-------|------------------------------------|-------------------------------------|----|
| 1     | Amount of computers displayed (0)  | Amount of computers displayed (0)   |✔|
| 2     | Amount of computers displayed (1)  | Amount of computers displayed (1)   |✔|
| 3     | Amount of computers displayed (2)  | Amount of computers displayed (2)   |✔|
| 4     | Amount of computers displayed (3)  | Amount of computers displayed (3)   |✔|
| 5     | Amount of computers displayed (4)  | Amount of computers displayed (4)   |✔|
| 6     | Amount of computers displayed (5)  | Amount of computers displayed (5)   |✔|
| 7     | Amount of computers displayed (6)  | Amount of computers displayed (6)   |✔|
| 8     | Amount of computers displayed (7)  | Amount of computers displayed (7)   |✔|
| 9     | Amount of computers displayed (8)  | Amount of computers displayed (8)   |✔|
| 10    | Amount of computers displayed (9)  | Amount of computers displayed (9)   |✔|
| 11    | Amount of computers displayed (10) | Amount of computers displayed (10)  |✔|
| 12    | Amount of computers displayed (11) | Amount of computers displayed (11)  |✔|
| 13    | Amount of computers displayed (12) | Amount of computers displayed (12)  |✔|
| 14    | Amount of computers displayed (13) | Amount of computers displayed (13)  |✔|

![](http://i.imgur.com/vh6g54d.png)

Becuase one procedure was reused for each button, it not only makes the program far more efficiant and prevents code duplication, but also allows the debugging process to be a ton easier and prevents the cause of errors.

## Task 3

### Planning

Task 3 required me to create two buttons, ‘reserve’ and ‘cancel’ and to ensure that when the ‘reserve’ button is clicked, the
number of computers shown as available for that building is decremented. Similarly, the ‘cancel’
button increments the number of computers available.

For this task, there were multiple choices given to me, I however found that the use of the ```Button``` component was most suitable as it not only allowed it to be touched, but also allowed the disabling and enabling of it.

![](http://i.imgur.com/QsQMFSu.png)

**Source(s)**: http://ai2.appinventor.mit.edu/reference/components/userinterface.html#Button

I have also decieded to use ```HorizontalArrangement``` to align each button to make it easier to press and easy to use as it automatically sets height and width adjustments.

![](http://i.imgur.com/Wvb9wMH.png)

**Source(s)**: http://ai2.appinventor.mit.edu/reference/components/layout.html#HorizontalArrangement

![](http://code2flow.com/IOzVFy.code.png)

### Develpment

As said in the planning, two buttons, ‘reserve’ and ‘cancel’, were created and placed in a ```HorizontalArrangement```. The reserve button was renamed to "bpc_reserve" and the cancel button was renamed to "bpc_cancel":

![](http://i.imgur.com/p9oSxTN.png)

In terms of programming, a lot of thought and development went into it; firstly, a global variable was created called "current_building" which stores the building currently selected, this has been made for when the events for each button are set. The "current_building" is then set to "n" in the "bpc_run" function (as "n" is the building number passed to it).

A check using the "if" statement is made checking if the building has already been reserved or not. This has been by using the current building number as an index to "bpc_reserved" and checking if that value is true or not, if it's not true then the buildings computer can be reserved and the reserve button is set to enabled and the cancel button is disabled through the use of the ```Enabled``` property. If however, it is already reserved, the reserve button is disabled and the cancel button is enabled:

![](http://i.imgur.com/fHyLST9.png)

The next part of the code is the "bpc_reserve" button event; through the use of the ```Click``` event, it was possible to check whether the button had be clicked or not.

![](http://i.imgur.com/4IJSY5b.png)

When clicked, a check would be made (like shown and explained before) to check if the buildings computer hasn't been reserved already and if there were any computers avaliable. If not, through the use of the ```replace``` function, the building index ("current_building" was used here") in "bpc_reserved" was set to ```true``` (so it couldn't be reserved again), again using the ```replace``` function, the amount of computers avaliable in that building was decreased by 1 using the "bpc_avaliable" list.

And finally, "bpc_display" was called whilst disabling the reserve button and enabling the cancel button (using the ```Enabled``` property as discussed previously) in order to stop it from being reserved again.

The "bpc_cancel" button was made very similarly, however, instead of checking if the building hadn't been reserved, it checked if it had been reserved (so it can be cancelled), instead of decreasing amount of computers avaliable when pressed, instead of setting reserved to true, it set it to false and finally it made reserve true and cancel false.

### Testing

[insert testing intro]
[insert test table]

## Task 4

### Planning
This task required me to create a feature which displays each computer avaliable when a user touches a building that has none left. To do this I thought of many ways (such as multiple screens) but the most logical and simplest was to use the label "bpc_text" to notify the user of each building avaliable e.g. "None left, try these: B1 B2 B3..." and so on.

Since no new components will be added, not much research will be needed, however, to achieve this, I have acknowledged that "for" loops will need to be used to loop through each building to check which computers are avaliable. A for each loop will not be used as the index of the item will need to be reffered to:

![](https://i.imgsafe.org/1795283.png)

**Source(s)**: http://appinventor.mit.edu/explore/ai2/support/blocks/control.html#forrange

![](http://code2flow.com/Vldwmv.code.png)

### Development
No new compenents needed to be added or configured so the programming was immediantly started. In the "bpc_run" proceudre, a check was made to see if there are no computers in that building avaliable for reservation. If none are avaliable, then both buttons are set to false (as it shouldn't be possible to reserve or cancel an empty building):

![](http://i.imgur.com/aq9ypGj.png)

The next step was to make "bpc_text" display the buildings avaliable, I first set the text to "None left, try these: " through the use of the ```text``` property to begin the structuring of the sentance. As discussed before, a "for" loop will be used to iterate through each building and check if there are computers avaliable. The "length of list" function is used here to work out how many items there are that should be iterated through.

To check if a computer was avaliable in each building, "i" in the for loop was used as an building index for "bpc_avaliable" and that was then checked to see if it was over 0 (a computer avaliable). If it was, then "bpc_text" is concatenated with the building number (the method for wont need to be explained as I have used and explained this previously).

![](http://i.imgur.com/Ji8Aed9.png)

### Testing
When testing the program there was only one building button to test, the first building. When testing the program there were a few bugs, it would produce odd results that were unexpected. This was due to accidently selecting an item to be used as a key for accessing the computer count in the building when in actual fact it was meant to be an index, this has now been fixed and when pressing building one (the only building with no computers avaliable).

[insert screenshots]

## Task 5

To evaluate success of my app, each task will be set to multiple specification points:

1. It must be time efficiant; all time used sparingly
2. It must be developed with a reasonable amount of efficiancy
3. The output must be tested
4. The output must eventually work as planned

- Task 1: Task 1

///////////////////////////////////////////////

Over all, the success of my application has been great. it's not only programmed and designed efficiently but is also extremely useful to a university member:

Task Evaluations:

- Task 1:  Task 1 was very simple and took very little time, it took no more than 10 minutes to complete and no errors were made thus making the development of it very successful. 
- Task 2: Task 2 was somewhat more complex as it required programming and a few errors were ran into; when creating the task, I original planned to use the ```button``` component, however, when taking of its visbility property it could no longer be pressed which was an issue. So as an alternate, I had to use ImageSprites with a transparent background which took longer as photoshop (an  example of photo editing software) had to be opened. Other than that, the development of it was quite quick and successful and that task is where the main backbone of the program was developed.
- Task 3: Task 3 has arguably been the most time spending task out of them all, however, because i've created software like this in the past, I had an idea in mind which allowed me to quickly and efficiantly program it on App Inventor. In terms of errors, there were none, but I do believe time could of spent more wisely on that task to make it possibly more of a success.
- Task 4: Task 4 was an interesting task as it allows many various ways to achieve it which mostly take a long time, I however thought the idea to use the text label to display the names of each computer avaliable which technically achieves the task whilst using no new components (meaning less code and time) and only a few blocks of code. I would say this had to be one of the most successful task done.

The usefulness of this program is quite extreme, students will not have to make phone calls or meet in person to book which generally is more time consuming. The fact that they're able to instantly access a copy of their unversity buildings and are avaliable to book and cancel computers with just a few clicks of a button wherever they are and whenever they want. This allos students to save time and focus on more valuable things such as studying.

## Task 6:
This task requires that a possible additional feature is though of and explain; there were many different ideas that came to mind but the most obvious one was to add sounds to both the cancel and reserve button. Although this is quite a simple feature, I feel like it's very effective and increases the quality and userablity of the application by quite a reasonable amount; it notifies the user with a sound to ensure them that they have pressed it and the computer has infact been reserved/cancelled.

So all though this feature isn't complex at all, it makes a somewhat big difference that users would highly appriciate; not to mention that it's simple to implement and doesn't further complicate the userability.

## Task 7:

### Planning
For this task, I have to implement the feature described in the previous task (ensure that when either the cancel or reservebutton is pressed, a click sound is played). In order to achieve this, a new component of App Inventor will need to be researched and used; the new feature will be the ```Sound``` component.

![](https://i.imgsafe.org/c649fb1.png)

**Source(s)**: https://i.imgsafe.org/c649fb1.png

In order to add a click sound to the button(s), a click sound will need to be obtained. I have researched and found a free click sound that can be used: http://soundbible.com/772-Button.html

![](http://code2flow.com/TfF00y.code.png)

### Development
To start off, a non-visible ```Sound``` component was added to my application, it was named renamed to "click_sound" (for readability purposes). Its source was then changed to the click sound found earlier:

![](https://i.imgsafe.org/c8d8a96.png)

The next step was to add the code; since events for each button were already added previously, instead of making more events, I have decieded to add the play sound blocks (function which starts the sound) to the start of both the "bpc_reserve.click" event and the "bpc_cancel.click" event for effeciancy purposes (avoiding code duplication):

![](https://i.imgsafe.org/f090916.png)

### Testing
Both buttons need to be tested to ensure each sound is being played correctly.

|Button       |Expected outcome            |Actual outcome             |✔/✘|
|-------------|----------------------------|---------------------------|----|
| bpc_reserve | The click sound is played  | The click sound is played |✔|
| bpc_cancel  | The click sound is played  | The click sound is played |✔|

Since both buttons did exactly as expected, no further development is needed here.

## Task 8:
If this app was to be properly implemented then an online database would be required; there are many issues that need to be thought about:

- The database would require a high speed server to run on so users can quickly access the data without any lag, however, a high speed will be somewhat costly and maintenance would also be required.
- It is also important that the client side of the application does not cancel or book reservations until it has gone to the server and has been confirmed, if there's a slow internet connection then this will prevent reservations being shown as booked even though it hasn't reached to the server yet meaning the user will think they have booked when they in actual fact haven't.
-  Data validation will also need to be existant. For example, two users cannot book a room at the same time, this can cause bad results which possibly break the database entiry. A way to prevent this is by having a system which records the timing of each reservation and allowing the fastest one.
-  Security will need to be applied to the database too, it's important that only university members can reserve and cancel computer reservations, to do this the most logical, common and efficiant way would to make an account system (user + password). Another aspect of security is ensuring that the database is hack proof as if hackers were to hack the database then a lot of sensitive information would be leaked. This could possibly be done through a form of encyrption.

**Source(s)**: https://en.wikipedia.org/wiki/Database
